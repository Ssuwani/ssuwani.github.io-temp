---
title: '[백준-다이나믹프로그래밍] 계단 오르기'
date: '2021-11-19'
category: 'algorithm'
description: ''
emoji: '1️⃣'

---

[[info | 백준 게단오르기 문제 보러가기]]
| https://www.acmicpc.net/problem/2579

## 문제 요약

계단에 따른 점수가 주어진다. 이때 다음 조건을 만족하면서 계단을 올라 얻을 수 있는 점수의 최댓값을 출력하라

1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
3. 마지막 도착 계단은 반드시 밟아야 한다.

#### 조건

- 계단은 300개 이하로 주어진다

## 문제 접근 방식

1. 풀이의 아이디어는 간단하다.. 각각의 계단에서 최선을 다하면 된다.
1. 첫번째 계단을 오를 때 받을 수 있는 최고 점수는 첫번째 계단을 오르는 것이다.
1. 두번쨰 계단을 오를 때 받을 수 있는 최고 점수는 첫번째 계단을 지나 두번째 계단을 오르는 것이다.
1. 세번째 계단부터 문제인데, 연속으로 3개의 계단을 오를 수 없기 때문인다.
1. 세번쨰 계단을 오를 때 받을 수 있는 최고 점수는 첫번째 계단을 지나 세번째 계단을 오르는 점수와 두번째 계단을 지나 세번째 계단을 지나 오르는 점수 중 더 큰값이다.
1. 네번째 부터는 이전의 값을 참조해야한다. 이때까지 최선을 다했으므로 가능한 이야기다.
1. 네번쨰 계단을 오를 때 받을 수 있는 최고 점수는 두번째 계단을 올랐을 때 받은 점수에 네번째 계단을 오를 때 받을 수 있는 점수에 첫번째 계단을 오를 때 받았던 점수에 세번째, 네번째를 연속으로 올랐을 때 받은 점수 중 큰값이다.
1. 풀이는 조건에 따라 최선을 다했을 뿐이다.

## 풀이코드

```python
n = int(input())
seq = [int(input()) for _ in range(n)]
if n == 1 or n == 2:
    print(sum(seq))
else:
    dp = []

    dp.append(seq[0])
    dp.append(seq[0] + seq[1])
    dp.append(max(seq[0] + seq[2], seq[1]+seq[2]))

    for i in range(3, len(seq)):
        dp.append(max(dp[i-2]+seq[i], dp[i-3]+seq[i-1]+seq[i]))

    print(dp[-1])
```





